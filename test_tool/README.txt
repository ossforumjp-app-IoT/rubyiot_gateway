2015年12月24日

サーバの性能検証用のプログラムです。
使い方1：ruby main.rb X Y Z
　XはGWの数を示します。
　YはGWのインデックスナンバーの初期値です。
　main.rbを1プロセスで実行する場合は得に気にする必要はありませんが、
　main.shを実行する場合はプログラム内部でのインデックスがかぶらないように
　引数を指定する必要があります。（main.shを参照して下さい）
　Zは1台のGWのリクエスト回数を表しています。

使い方2: ./main.sh
　main.rbを複数プロセスで実行するためのスクリプトです。
　単にバックグラウンドで複数のmain.rbを引数を変えて実行しているだけです。

main.sh:
　main.rbを複数で実行するためのスクリプトです。
　インデックスが被らないように注意してください。
　例えば2プロセスで、計100GWを100リクエストで実行するには下記のように記述します。

  ============================
  ruby main.rb 50 0 100 &
  ruby main.rb 50 50 100 &
  ============================

main.rb：
　メインプログラムです。
　複数のゲートウェイを生成して、各ゲートウェイは
　スレッドで走らせてデータをサーバに投げています。

　メインプログラム全体の流れは下記の通りです。

　１．ゲートウェイ生成⇒ログイン⇒センサデバイスID取得

　２．大量データ生成

　３．各ゲートウェイをスレッド化⇒各ゲートウェイからデータ送信

　４．各ゲートウェイログアウト

　プログラム中の変数
　　gw_numはゲートウェイの数を表しています。
　　request_timesはデータをサーバに送信する回数を表しています。
　ゲートウェイ100台×2000リクエストで検証済です。

gw.rb:
　サーバのAPIを実装しています。
　各ゲートウェイ毎にセッションを生成します。
　実装して、検証済のメソッドは下記の通りです。
　　initialize
　　login
　　post_device
    sotre_data
　　log
　　logout
　他のAPIも作成はしていますが、検証済ではありません。

　各ゲートウェイはゲートウェイ毎にログファイルを生成します。
　ログファイの内容は主に、各メソッド内で使用するAPIのレスポンス時間を測定しています。
　

massive_data:
　大量データ生成のプログラムです。
　基本はrubyiot_serverのcreate_dummydata.rbをベースにさせていただいております。
　メソッドmake_dataは(5 * 24 * 60 * 60 / 3)の数だけデータを生成し、
　キューに全てを格納して、キューを返します。
　mainプログラムではキューを受け取り、各ゲートウェイはキューからポップしたデータをサーバに送信します。

register_gw.rb
　サーバにゲートウェイを登録するスクリプトです。
　ゲートウェイの数はgw_numで指定します。

